; AutoExp.Dat - templates for automatically expanding data
; Copyright(c) Microsoft Corporation. All Rights Reserved.
;---------------------------------------------------------------
;
; While debugging, Data Tips and items in the Watch and Variable
; windows are automatically expanded to show their most important
; elements. The expansion follows the format given by the rules
; in this file. You can add rules for your types or change the
; predefined rules.
;
; For good examples, read the rules in this file.
;
; To find what the debugger considers the type of a variable to
; be, add it to the Watch window and look at the Type column.
;
; An AutoExpand rule is a line with the name of a type, an equals
; sign, and text with replaceable parts in angle brackets. The
; part in angle brackets names a member of the type and an
; optional Watch format specifier.
;
; AutoExpand rules use the following syntax. The equals sign (=),
; angle brackets (<>), and comma are taken literally. Square
; brackets ([]) indicate optional items.
;
; type=[text]<member[,format]>...
;
; type		Name of the type (may be followed by <*> for template
;			types such as the ATL types listed below).
;
; text		Any text.Usually the name of the member to display,
;			or a shorthand name for the member.
;
; member	Name of a member to display.
;
; format	Watch format specifier. One of the following:
;
;	Letter	Description					Sample		   Display
;	------	--------------------------	------------   -------------
;	d,i		Signed decimal integer		0xF000F065,d   -268373915
;	u		Unsigned decimal integer	0x0065,u	   101
;	o		Unsigned octal integer		0xF065,o	   0170145
;	x,X		Hexadecimal integer			61541,X		   0X0000F065
;	l,h		long or short prefix for	00406042,hx    0x0c22
;			  d, i, u, o, x, X
;	f		Signed floating-point		3./2.,f		   1.500000
;	e		Signed scientific-notation	3./2.,e		   1.500000e+000
;	g		Shorter of e and f			3./2.,g		   1.5
;	c		Single character			0x0065,c	   'e'
;	s		Zero-terminated string		pVar,s		   "Hello world"
;	su		Unicode string				pVar,su		   "Hello world"
;
; For details of other format specifiers see Help under:
; "format specifiers/watch variable"
;
; The special format <,t> specifies the name of the most-derived
; type of the object. This is especially useful with pointers or
; references to a base class.
;
; If there is no rule for a class, the base classes are checked for
; a matching rule.
;
; There are some special entries allowed in the AutoExpand section:
; $BUILTIN is used to display more complex types that need to do more
; than just show a member variable or two.
; $ADDIN allows external DLLs to be added to display even more complex
; types via the EE Add-in API. The first argument is the DLL name, the
; second argument is the name of the export from the DLL to use. For
; further information on this API see the sample called EEAddIn.
;
; WARNING: if hexadecimal mode is on in the watch window, all numbers here are
; evaluated in hex, e.g. 42 becomes 0x42

[AutoExpand]
;OCCT_DEBUG_START
; Toolkit TKernel
Standard_Transient=<,t> count=<count,d>
Handle_Standard_Transient=<entity,x> count=<entity->count,d> <,t>
TCollection_AsciiString=<mylength,d> <mystring,s>
TCollection_HAsciiString=<myString.mylength,d> <myString.mystring,s>
TCollection_ExtendedString=<mylength,d> <mystring,su>
TCollection_HExtendedString=<myString.mylength,d> <myString.mystring,su>
TCollection_BaseSequence=size=<Size,d> curr=<CurrentIndex,d>
TCollection_BasicMap=size=<mySize,d>
NCollection_BaseSequence=size=<mySize,d> curr=<myCurrentIndex,d>
NCollection_BaseList=length=<myLength,d>
NCollection_BaseMap=size=<mySize,d> buckets=<myNbBuckets>
NCollection_BaseVector=length=<myLength,d>

; Toolkit TKMath
gp_XYZ=<x,g>, <y,g>, <z,g>
gp_Pnt=<coord.x,g>, <coord.y,g>, <coord.z,g>
gp_Vec=<coord.x,g>, <coord.y,g>, <coord.z,g>
gp_Dir=<coord.x,g>, <coord.y,g>, <coord.z,g>
gp_XY=<x,g>, <y,g>
gp_Pnt2d=<coord.x,g>, <coord.y,g>
gp_Dir2d=<coord.x,g>, <coord.y,g>
gp_Vec2d=<coord.x,g>, <coord.y,g>
gp_Mat2d={<matrix[0][0],g>,<matrix[0][1],g>}, {<matrix[1][0],g>,<matrix[1][1],g>}
gp_Ax1=loc={<loc.coord.x,g>, <loc.coord.y,g>, <loc.coord.z,g>} vdir={<vdir.coord.x,g>, <vdir.coord.y,g>, <vdir.coord.z,g>}

; Toolkit TKBRep
TopoDS_Shape=<myTShape.entity,x> <myOrient>

; Toolkit TKLCAF
TDF_Label=<myLabelNode,x> tag=<myLabelNode->myTag>
TDF_LabelNode=tag=<myTag,d>
TDocStd_Document=format=<myStorageFormat.mystring,su> count=<count,d> <,t>

;OCCT_DEBUG_END

; from windef.h
tagPOINT =x=<x> y=<y>
tagRECT =top=<top> bottom=<bottom> left=<left> right=<right>

; from winuser.h
tagMSG =msg=<message,x> wp=<wParam,x> lp=<lParam,x>

; intrinsics
__m64 =<m64_i64,x>
__m128=$BUILTIN(M128)
__m128i=$BUILTIN(M128I)
__m128d=$BUILTIN(M128D)

; from afxwin.h
CDC =hDC=<m_hDC> attrib=<m_hAttribDC>
CPaintDC =<,t> hWnd=<m_hWnd>
CPoint =x=<x> y=<y>
CRect =top=<top> bottom=<bottom> left=<left> right=<right>
CSize =cx=<cx> cy=<cy>
CWnd =<,t> hWnd=<m_hWnd>
CWinApp =<,t> <m_pszAppName,s>
CWinThread =<,t> h=<m_hThread> proc=<m_pfnThreadProc>

; from afxcoll.h
CPtrList =cnt=<m_nCount>

; from afxstat_.h
CProcessLocalObject =<,t>
CThreadLocalObject =<,t>

; from afx.h
CArchiveException =cause=<m_cause>
CFile =hFile=<m_hFile> name=<m_strFileName.m_pchData,s>
CFileException =cause=<m_cause> OS Error=m_lOsError
CMemFile =pos=<m_nPosition> size=<m_nFileSize>
CObject =<,t>
CRuntimeClass =<m_lpszClassName,s>
CStdioFile =FILE*=<m_pStream> name=<m_strFilename.m_pchData,s>
CTimeSpan =time=<m_time>
CTime =time=<m_time>

; from afxcoll.h
CByteArray =count=<m_nCount>
CStringList =count=<m_nCount>
; same for all CXXXArray classes
; same for CXXXList
; same for CMapXXToXX

; various string classes from MFC & ATL

_com_error=<m_hresult,hr>
_bstr_t=<m_Data->m_wstr,su> (<m_Data->m_RefCount,u>)
_com_ptr_t<*>=<m_pInterface>
_LARGE_INTEGER=<QuadPart>
_ULARGE_INTEGER=<QuadPart>
ATL::CComPtr<*>=<p>

ATL::CComQIPtr<*>=<p>

tagVARIANT=$BUILTIN(VARIANT)
VARIANT=$BUILTIN(VARIANT)
_GUID=$BUILTIN(GUID)

; see EEAddIn sample for how to use these
;_SYSTEMTIME=$ADDIN(EEAddIn.dll,AddIn_SystemTime)
;_FILETIME=$ADDIN(EEAddIn.dll,AddIn_FileTime)

std::binder1st<*>= op=<op> value=<value>
std::binder2nd<*>= op=<op> value=<value>
std::less<*>=lessthan
std::greater<*>=greaterthan

[Visualizer]
;OCCT_DEBUG_START
; OPEN CASCADE visualizers -----------------------------------------[ start ]--
;------------------------------------------------------------------------------
; Feel free to modify these visualizers to suit yours needs! But please let us
; know about the changes you make, so we continuously improve the visualizers.
;------------------------------------------------------------------------------
; OPEN CASCADE visualizers -------------------------------------------[ end ]--
;OCCT_DEBUG_END

; This section contains visualizers for STL and ATL containers
; DO NOT MODIFY
ATL::CStringT<char,*>|CSimpleStringT<char,*>|ATL::CSimpleStringT<char,*>{
		preview			([$e.m_pszData,s])
		stringview		([$e.m_pszData,sb])
}
ATL::CStringT<wchar_t,*>|CSimpleStringT<wchar_t,*>|ATL::CSimpleStringT<wchar_t,*>|ATL::CStringT<unsigned short,*>|CSimpleStringT<unsigned short,*>|ATL::CSimpleStringT<unsigned short,*>{
		preview			([$e.m_pszData,su])
		stringview		([$e.m_pszData,sub])
}
ATL::CComBSTR{
		preview			([$e.m_str,su])
		stringview		([$e.m_str,sub])
}
;------------------------------------------------------------------------------
;  std::vector<bool,*> specialization
;------------------------------------------------------------------------------
std::vector<bool,*>{
	children
	(
		#array
		(
			expr : ($e._Myvec._Myfirst[$i / _VBITS] >> ($i % _VBITS)),
			size : ($e._Mysize)
		)  : (bool)($e & 1)
	)
	preview
	(
		#(
			"[", $e._Mysize , "](",
			#array
			(
				expr : ($e._Myvec._Myfirst[$i / _VBITS] >> ($i % _VBITS)),
				size : ($e._Mysize)
			)  : (bool)($e & 1),
			")"
		)
	)
}
std::vector<bool,*>::iterator|std::vector<bool,*>::const_iterator|std::_Vb_iterator<*>|std::_Vb_const_iterator<*>{
	preview		( #( (bool) (((*$e._Myptr) >> $e._Myoff) & 1)))
	children	( #( ptr: (bool) (((*$e._Myptr) >> $e._Myoff) & 1)))
}
;------------------------------------------------------------------------------
;  std::vector
;------------------------------------------------------------------------------
std::vector<*>{
	children
	(
		#array
		(
			expr :		($e._Myfirst)[$i],
			size :		$e._Mylast-$e._Myfirst
		)
	)
	preview
	(
		#(
			"[", $e._Mylast - $e._Myfirst , "](",
			#array
			(
				expr :	($e._Myfirst)[$i],
				size :	$e._Mylast-$e._Myfirst
			),
			")"
		)
	)
}
std::_Vector_iterator<*>|std::_Vector_const_iterator<*>{
	preview		( #(*$e._Myptr))
	children	( #(ptr: *$e._Myptr))
}
;------------------------------------------------------------------------------
;  std::string/basic_string
;------------------------------------------------------------------------------
std::basic_string<char,*>{
	preview		( #if(($e._Myres) < ($e._BUF_SIZE)) ( [$e._Bx._Buf,s]) #else ( [$e._Bx._Ptr,s]))
	stringview	( #if(($e._Myres) < ($e._BUF_SIZE)) ( [$e._Bx._Buf,sb]) #else ( [$e._Bx._Ptr,sb]))
	children
	(
		#if(($e._Myres) < ($e._BUF_SIZE))
		(
			#([actual members]: [$e,!] , #array( expr: $e._Bx._Buf[$i], size: $e._Mysize))
		)
		#else
		(
			#([actual members]: [$e,!],  #array( expr: $e._Bx._Ptr[$i], size: $e._Mysize))
		)
	)
}
std::basic_string<unsigned short,*>|std::basic_string<wchar_t,*>{
	preview
	(
		#if(($e._Myres) < ($e._BUF_SIZE)) ( [$e._Bx._Buf,su] )
		#else ( [$e._Bx._Ptr,su] )
	)
	stringview
	(
		#if(($e._Myres) < ($e._BUF_SIZE)) ( [$e._Bx._Buf,sub] )
		#else ( [$e._Bx._Ptr,sub] )
	)
	children
	(
		#if(($e._Myres) < ($e._BUF_SIZE))
		(
			#(
				[actual members]: [$e,!] ,
				#array( expr: $e._Bx._Buf[$i], size: $e._Mysize)
			)
		)
		#else
		(
			#(
				[actual members]: [$e,!],
				#array( expr: $e._Bx._Ptr[$i], size: $e._Mysize)
			)
		)
	)
}
std::basic_string<*>::iterator|std::basic_string<*>::const_iterator|std::_String_iterator<*>|std::_String_const_iterator<*>{
		preview ( #( $e._Myptr ))
		children ( #( ptr: $e._Myptr ))
}
std::pair<*>{
	preview ( #( "(", $e.first, ",", $e.second , ")"))
}
;------------------------------------------------------------------------------
;  std::auto_ptr
;------------------------------------------------------------------------------
std::auto_ptr<*>{
	preview
	(
		#(
			"auto_ptr ",
			(*(($T1 *)$e._Myptr))
		 )
	)
	children
	(
		#(
			ptr: (*(($T1 *)$e._Myptr))
		)
	)
}
;------------------------------------------------------------------------------
;  std::map
;------------------------------------------------------------------------------
std::map<*>{
	children
	(
		#tree
		(
			head : $e._Myhead->_Parent,
			skip : $e._Myhead,
			size : $e._Mysize,
			left : _Left,
			right : _Right
		) : $e._Myval
	)
	preview
	(
		#(
			"[", $e._Mysize, "](",
			#tree
			(
				head : $e._Myhead->_Parent,
				skip : $e._Myhead,
				size : $e._Mysize,
				left : _Left,
				right : _Right
			) : $e._Myval,
			")"
		)
	)
}
;------------------------------------------------------------------------------
;  std::multi_map
;------------------------------------------------------------------------------
std::multimap<*>{
	children
	(
		#tree
		(
			head : $e._Myhead->_Parent,
			skip : $e._Myhead,
			size : $e._Mysize,
			left : _Left,
			right : _Right
		) : $e._Myval
	)
	preview
	(
		#(
			"[", $e._Mysize, "](",
			#tree
			(
				head : $e._Myhead->_Parent,
				skip : $e._Myhead,
				size : $e._Mysize,
				left : _Left,
				right : _Right
			) : $e._Myval,
			")"
		)
	)
}
;------------------------------------------------------------------------------
;  std::list
;------------------------------------------------------------------------------
std::list<*>{
	children
	(
		#list
		(
			head : $e._Myhead->_Next,
			size : $e._Mysize,
			next : _Next
		) : $e._Myval
	)
	preview
	(
		#(
			"[", $e._Mysize, "](",
			#list
			(
				head : $e._Myhead->_Next,
				size : $e._Mysize,
				next : _Next
			) : $e._Myval,
			")"
		)
	)
}
std::list<*>::iterator|std::list<*>::const_iterator|std::list<*>::_Iterator<1>|std::list<*>::_Const_iterator<1>{
	preview ( #($e._Ptr->_Myval))
	children ( #(ptr: $e._Ptr->_Myval))
}
;------------------------------------------------------------------------------
;  std::bitset	<bitset>
;------------------------------------------------------------------------------
std::bitset<*>{
	preview
	(
		#(
			"[", $e.digits, "](",
			#array
			(
				expr :	($e._Array[$i / $e._Bitsperword] >> ($i % $e._Bitsperword)),
				size :	$e.digits
			) : [($e & 1),d],
			")"
		)
	)
	children
	(
		#array
		(
			expr :	($e._Array[$i / $e._Bitsperword] >> ($i % $e._Bitsperword)),
			size :	$e.digits
		) : (bool)($e & 1)
	)
}
std::bitset<*>::reference{
	preview
	(
		#(
			"bitset[", $e._Mypos, "] = ",
			(bool)(($e._Pbitset->_Array[$i / _Bitsperword] >> ($e._Mypos % _Bitsperword)) & 1)
		)
	)
}
;------------------------------------------------------------------------------
;  std::deque
;------------------------------------------------------------------------------
std::deque<*>{
	children
	(
		#array
		(
			expr : $e._Map[ (($i + $e._Myoff) / $e._EEN_DS) % $e._Mapsize][($i + $e._Myoff) % $e._EEN_DS],
			size : $e._Mysize
		)
	)
	preview
	(
		#(
			"[", $e._Mysize, "](",
			#array
			(
				expr : $e._Map[ (($i + $e._Myoff) / $e._EEN_DS) % $e._Mapsize][($i + $e._Myoff) % $e._EEN_DS],
				size : $e._Mysize
			),
			")"
		)
	)
}
std::deque<*,*>::iterator|std::_Deque_iterator<*,*,*>|std::_Deque_const_iterator<*,*,*>{
	preview
	(
		#if( $e._EEN_HID == 0 )
		(
			#if( $e._Myoff >= ((std::deque<$T1,$T2 > *)($e._Myaux->_Mycontainer))->_Myoff + ((std::deque<$T1,$T2 > *)($e._Myaux->_Mycontainer))->_Mysize)
			(
				#("<end>")
			)
			#else
			(
				#(
					"deque[",
					$e._Myoff - ((std::deque<$T1,$T2 > *)($e._Myaux->_Mycontainer))->_Myoff,
					"] = ",
					((std::deque<$T1,$T2 > *)($e._Myaux->_Mycontainer))->_Map[ (($e._Myoff) / ((std::deque<$T1,$T2 > *)($e._Myaux->_Mycontainer))->_EEN_DS) % ((std::deque<$T1,$T2 > *)$e._Myaux->_Mycontainer)->_Mapsize][$e._Myoff % ((std::deque<$T1,$T2 > *)($e._Myaux->_Mycontainer))->_EEN_DS]
				)
			)
		)
		#else
		(
			#if( $e._Myoff >= ((std::deque<$T1,$T2 > *)$e._Mycont)->_Myoff + ((std::deque<$T1,$T2 > *)$e._Mycont)->_Mysize)
			(
				#("<end>")
			)
			#else
			(
				#(
					"deque[",
					$e._Myoff - ((std::deque<$T1,$T2 > *)$e._Mycont)->_Myoff,
					"] = ",
					((std::deque<$T1,$T2 > *)$e._Mycont)->_Map[ (($e._Myoff) / ((std::deque<$T1,$T2 > *)$e._Mycont)->_EEN_DS) % ((std::deque<$T1,$T2 > *)$e._Mycont)->_Mapsize][$e._Myoff % ((std::deque<$T1,$T2 > *)$e._Mycont)->_EEN_DS]
				)
			)
		)
	)
	children
	(
		#if( $e._EEN_HID == 0 )
		(
			#if( ((std::deque<$T1,$T2 > *)($e._Myaux->_Mycontainer))->_Myoff + ((std::deque<$T1,$T2 > *)($e._Myaux->_Mycontainer))->_Mysize > $e._Myoff)
			(
				#(
					ptr: ((std::deque<$T1,$T2 > *)($e._Myaux->_Mycontainer))->_Map[ ($e._Myoff / ((std::deque<$T1,$T2 > *)($e._Myaux->_Mycontainer))->_EEN_DS) % ((std::deque<$T1,$T2 > *)($e._Myaux->_Mycontainer))->_Mapsize][$e._Myoff % ((std::deque<$T1,$T2 > *)($e._Myaux->_Mycontainer))->_EEN_DS]
				)
			)
		)
		#else
		(
			#if( ((std::deque<$T1,$T2 > *)$e._Mycont)->_Myoff + ((std::deque<$T1,$T2 > *)$e._Mycont)->_Mysize > $e._Myoff)
			(
				#(
					ptr: ((std::deque<$T1,$T2 > *)$e._Mycont)->_Map[ ($e._Myoff / ((std::deque<$T1,$T2 > *)$e._Mycont)->_EEN_DS) % ((std::deque<$T1,$T2 > *)$e._Mycont)->_Mapsize][$e._Myoff % ((std::deque<$T1,$T2 > *)$e._Mycont)->_EEN_DS]
				)
			)
		)
	)
}
;------------------------------------------------------------------------------
;  std::queue
;------------------------------------------------------------------------------
std::queue<*>{
	children
	(
		#array
		(
			expr : $e.c._Map[ (($i + $e.c._Myoff) / $e.c._EEN_DS) % $e.c._Mapsize][($i + $e.c._Myoff) % $e.c._EEN_DS],
			size : $e.c._Mysize
		)
	)
	preview
	(
		#(
			"[", $e.c._Mysize, "](",
			#array
			(
				expr : $e.c._Map[ (($i + $e.c._Myoff) / $e.c._EEN_DS) % $e.c._Mapsize][($i + $e.c._Myoff) % $e.c._EEN_DS],
				size : $e.c._Mysize
			),
			")"
		)
	)
}
;------------------------------------------------------------------------------
;  std::priority_queue
;------------------------------------------------------------------------------
std::priority_queue<*>{
	preview ( $e.c)
}
;------------------------------------------------------------------------------
;  std::set
;------------------------------------------------------------------------------
std::set<*>{
	preview
	(
		#(
			"[", $e._Mysize , "](",
			#tree
			(
				head : $e._Myhead->_Parent,
				skip : $e._Myhead,
				left : _Left,
				right : _Right,
				size  : $e._Mysize
			) : $e._Myval,
			")"
		)
	)
	children
	(
		#tree
		(
			head : $e._Myhead->_Parent,
			skip : $e._Myhead,
			left : _Left,
			right : _Right,
			size  : $e._Mysize
		) : $e._Myval
	)
}
;------------------------------------------------------------------------------
;  std::multi_set
;------------------------------------------------------------------------------
std::multiset<*>{
	preview
	(
		#(
			"[", $e._Mysize , "](",
			#tree
			(
				head : $e._Myhead->_Parent,
				skip : $e._Myhead,
				left : _Left,
				right : _Right,
				size  : $e._Mysize
			) : $e._Myval,
			")"
		)
	)
	children
	(
		#tree
		(
			head : $e._Myhead->_Parent,
			skip : $e._Myhead,
			left : _Left,
			right : _Right,
			size  : $e._Mysize
		) : $e._Myval
	)
}
;------------------------------------------------------------------------------
;  std::_Tree (shared my map/multimap/set/multiset)
;------------------------------------------------------------------------------
std::_Tree<*>::iterator|std::_Tree<*>::const_iterator{
	preview		( #($e._Ptr->_Myval))
	children	( #(ptr: $e._Ptr->_Myval))
}
;------------------------------------------------------------------------------
;  std::stack
;------------------------------------------------------------------------------
std::stack<*>{
	children
	(
		#array
		(
			expr : $e.c._Map[ (($i + $e.c._Myoff) / $e.c._EEN_DS) % $e.c._Mapsize][($i + $e.c._Myoff) % $e.c._EEN_DS],
			size : $e.c._Mysize
			)
	)
	preview
	(
		#(
			"[", $e.c._Mysize , "](",
			#array
			(
				expr : $e.c._Map[ (($i + $e.c._Myoff) / $e.c._EEN_DS) % $e.c._Mapsize][($i + $e.c._Myoff) % $e.c._EEN_DS],
				size : $e.c._Mysize
			),
			")"
		)
	)
}
;------------------------------------------------------------------------------
;  stdext::hash_map
;  stdext::hash_multimap
;  stdext::hash_set
;  stdext::hash_multiset
;------------------------------------------------------------------------------
stdext::hash_map<*>|stdext::hash_multimap<*>|stdext::hash_set<*>|stdext::hash_multiset<*>{
	preview
	(
		#(
			"[", $e._List._Mysize, "](",
			#list
			(
				head : $e._List._Myhead->_Next,
				size : $e._List._Mysize,
				next : _Next
			) : $e._Myval,
			")"
		)
	)
	children
	(
		#list
		(
			head : $e._List._Myhead->_Next,
			size : $e._List._Mysize,
			next : _Next
		) : $e._Myval
	)
}
;------------------------------------------------------------------------------
;  std::complex
;------------------------------------------------------------------------------
std::complex<*>{
	children
	(
		#(
			real: $e._Val[0],
			imaginary: $e._Val[1]
		)
	)
	preview
	(
		#if($e._Val[1] != 0)
		(
			#if ($e._Val[0] != 0)
			(	; Real and Imaginary components
				#if ($e._Val[1] >= 0)
					( #($e._Val[0],"+i*", $e._Val[1]))
				#else
					( #($e._Val[0],"-i*", -$e._Val[1]))
			)
			#else
			(	; Purely imaginary
				#if ($e._Val[1] >= 0.0)
				( #("i*", $e._Val[1]))
				#else
				( #("-i*", -$e._Val[1]))
			)
		)
		#else
		(		; Purely real
			$e._Val[0]
		)
	)
}
;------------------------------------------------------------------------------
;  std::valarray
;------------------------------------------------------------------------------
std::valarray<*>{
	preview
	(
		#(
			"[", $e._Mysize , "](",
			#array
			(
				expr :	($e._Myptr)[$i],
				size :	$e._Mysize
			),
			")"
		)
	)
	children
	(
		#array
		(
			expr :	($e._Myptr)[$i],
			size :	$e._Mysize
		)
	)
}
;------------------------------------------------------------------------------
;  PROPVARIANT
;------------------------------------------------------------------------------
; Visualizers for VT_VECTOR C arrays
tagCAC|tagCAUB|tagCAI|tagCAUI|tagCAL|tagCAUL|tagCAFLT|tagCADBL|tagCACY|tagCADATE|tagCABSTR|tagCABSTRBLOB|tagCABOOL|tagCASCODE|tagCAPROPVARIANT|tagCAH|tagCAUH|tagCALPSTR|tagCALPWSTR|tagCAFILETIME|tagCACLIPDATA|tagCACLSID{
	preview(
		#(
			"[", $e.cElems , "](",
			#array
			(
				expr :	($e.pElems)[$i],
				size :	$e.cElems
			),
			")"
		)
	)
	children
	(
		#array
		(
			expr :	($e.pElems)[$i],
			size :	$e.cElems
		)
	)
}
; Visualizers for SAFE ARRAY
tagSAFEARRAY|SAFEARRAY{
	preview(
		#if ($e.fFeatures & 0x0080)		; FADF_HAVEVARTYPE
		(
			; Switch on the variant type field - which is stored 4 bytes
			; before the beginning of the SAFEARRAY type
			#switch( ((unsigned *)&($e))[-1] )
			#case 0x2		; VT_I2 | VT_ARRAY
			(
				#(
					"safearray of I2 = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((signed short *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x3		; VT_I4 | VT_ARRAY
			(
				#(
					"safearray of I4 = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((signed int *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x4		; VT_R4 | VT_ARRAY
			(
				#(
					"safearray of R4 = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((float *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x5		; VT_R8 | VT_ARRAY
			(
				#(
					"safearray of R8 = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((double *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				 )
			)
			#case 0x6		; VT_CY | VT_ARRAY
			(
				#(
					"safearray of CY = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((CY *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x7		; VT_DATE | VT_ARRAY
			(
				#(
					"safearray of DATE = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((DATE *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x8		; VT_BSTR | VT_ARRAY
			(
				#(
					"safearray of BSTR = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((wchar_t **)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0xa		; VT_ERROR | VT_ARRAY
			(
				#(
					"safearray of ERROR = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((long *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0xb		; VT_BOOL | VT_ARRAY
			(
				#(
					"safearray of BOOL = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((short *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0xc		; VT_VARIANT | VT_ARRAY
			(
				#(
					"safearray of VARIANT = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((tagVARIANT *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x10		; VT_I1 | VT_ARRAY
			(
				#(
					"safearray of I1 = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((signed char *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x11		; VT_UI1 | VT_ARRAY
			(
				#(
					"safearray of UI1 = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((unsigned char *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x12		; VT_UI2 | VT_ARRAY
			(
				#(
					"safearray of UI2 = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((unsigned short *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					  ),
				")"
				)
			)
			#case 0x13		; VT_UI4 | VT_ARRAY
			(
				#(
					"safearray of UI4 = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((unsigned int *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x14		; VT_I8 | VT_ARRAY
			(
				#(
					"safearray of I8 = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((signed __int64 *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x15		; VT_UI8 | VT_ARRAY
			(
				#(
					"safearray of UI8 = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((unsigned __int64 *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x16		; VT_INT | VT_ARRAY
			(
				#(
					"safearray of INT = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((int *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x17		; VT_UINT | VT_ARRAY
			(
				#(
					"safearray of UINT = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((unsigned *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x1e		; VT_LPSTR | VT_ARRAY
			(
				#(
					"safearray of LPSTR = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((char **)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x1f		; VT_LPWSTR | VT_ARRAY
			(
				#(
					"safearray of LPWSTR = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((wchar_t **)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x40		; VT_FILETIME | VT_ARRAY
			(
				#(
					"safearray of FILETIME = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((FILETIME *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x47		; VT_CLIPDATA | VT_ARRAY
			(
				#(
					"safearray of CLIPDATA = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((CLIPDATA *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x48		; VT_CLSID | VT_ARRAY
			(
				#(
					"safearray of CLSID = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((CLSID *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
		)
		#elif ($e.fFeatures & 0x0100)	; FADF_BSTR
		(
			#("safearray of BSTR = ",#array(expr: $e.rgsabound[$i].cElements, size: $e.cDims) : #("[",$e,"]"), "(", #array(expr: ((wchar_t * *)$e.pvData)[$i], size: $e.rgsabound[$r].cElements, rank: $e.cDims, base: $e.rgsabound[$r].lLbound ), ")")
		)
		#elif ($e.fFeatures & 0x0200)	; FADF_UNKNOWN
		(
				#("safearray of IUnknown* = ",#array(expr: $e.rgsabound[$i].cElements, size: $e.cDims) : #("[",$e,"]"), "(", #array(expr: ((IUnknown *)$e.pvData)[$i], size: $e.rgsabound[$r].cElements, rank: $e.cDims, base: $e.rgsabound[$r].lLbound ), ")")
		)
		#elif ($e.fFeatures & 0x0400)	; FADF_DISPATCH
		(
				#("safearray of IDispatch* = ",#array(expr: $e.rgsabound[$i].cElements, size: $e.cDims) : #("[",$e,"]"), "(", #array(expr: ((IDispatch*)$e.pvData)[$i], size: $e.rgsabound[$r].cElements, rank: $e.cDims, base: $e.rgsabound[$r].lLbound ), ")")
		)
		#elif ($e.fFeatures & 0x0800)	; FADF_VARIANT
		(
				#("safearray of VARIANT = ",#array(expr: $e.rgsabound[$i].cElements, size: $e.cDims) : #("[",$e,"]"), "(", #array(expr: ((tagVARIANT *)$e.pvData)[$i], size: $e.rgsabound[$r].cElements, rank: $e.cDims, base: $e.rgsabound[$r].lLbound ), ")")
		)
	)
	children
	(
		#(		;[actual members]: [$e,!],
			#if ($e.fFeatures & 0x0080)		; FADF_HAVEVARTYPE
			(
				#switch( ((unsigned *)&($e))[-1] )		; for some reason the VT field is before the SAFEARRAY struct
				#case 2 ; VT_I2|VT_ARRAY
				(
					#array(
						expr: ((signed short *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 3 ; VT_I4|VT_ARRAY
				(
					#array(
						expr: ((signed int	 *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 4 ; VT_R4|VT_ARRAY
				(
					#array(
						expr: ((float *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 5 ; VT_R8|VT_ARRAY
				(
					#array(
						expr: ((double	*)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0x10		; VT_I1|VT_ARRAY
				(
					#array(
						expr: ((signed char *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0x11		; VT_UI1|VT_ARRAY
				(
					#array(
						expr: ((unsigned char *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0x12		; VT_UI2|VT_ARRAY
				(
					#array(
						expr: ((unsigned short *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0x13		; VT_UI4|VT_ARRAY
				(
					#array(
						expr: ((unsigned int *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0x14		; VT_I8|VT_ARRAY
				(
					#array(
						expr: ((signed __int64 *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0x15		; VT_UI8|VT_ARRAY
				(
					#array(
						expr: ((unsigned __int64 *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0x1e		; VT_LPSTR|VT_ARRAY
				(
					#array(
						expr: ((char * *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0x1f		; VT_LPWSTR|VT_ARRAY
				(
					#array(
						expr: ((wchar_t **)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0xc		; VT_VARIANT|VT_ARRAY
				(
					#array(
						expr: ((tagVARIANT *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0xb		; VT_BOOL|VT_ARRAY
				(
					#array(
						expr: ((short *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0xa		; VT_ERROR|VT_ARRAY
				(
					#array(
						expr: ((long *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 6 ; VT_CY|VT_ARRAY
				(
					#array(
						expr: ((CY *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 7 ; VT_DATE|VT_ARRAY
				(
					#array(
						expr: ((DATE *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0x40		; VT_FILETIME|VT_ARRAY
				(
					#array(
						expr: ((FILETIME *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0x48		; VT_CLSID|VT_ARRAY
				(
					#array(
						expr: ((CLSID *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0x47		; VT_CF|VT_ARRAY
				(
					#array(
						expr: ((CLIPDATA *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 8 ; VT_BSTR|VT_ARRAY
				(
					#array(
						expr: ((wchar_t * *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0x16		; VT_INT|VT_ARRAY
				(
					#array(
						expr: ((int *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0x17		; VT_UINT|VT_ARRAY
				(
					#array(
						expr: ((unsigned int*)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#default
				(
						#([actual members]: [$e,!])
				)
				#except
				(
						#([actual members]: [$e,!])
				)
			)
			#elif ($e.fFeatures & 0x0100)	; FADF_BSTR
			(
					#array(expr: ((wchar_t * *)$e.pvData)[$i], size: $e.rgsabound[$r].cElements, rank: $e.cDims, base: $e.rgsabound[$r].lLbound )
			)
			#elif ($e.fFeatures & 0x0200)	; FADF_UNKNOWN
			(
					#array(expr: ((IUnknown *)$e.pvData)[$i], size: $e.rgsabound[$r].cElements, rank: $e.cDims, base: $e.rgsabound[$r].lLbound )
			)
			#elif ($e.fFeatures & 0x0400)	; FADF_DISPATCH
			(
					#array(expr: ((IDispatch *)$e.pvData)[$i], size: $e.rgsabound[$r].cElements, rank: $e.cDims, base: $e.rgsabound[$r].lLbound )
			)
			#elif ($e.fFeatures & 0x0800)	; FADF_VARIANT
			(
					#array(expr: ((tagVARIANT *)$e.pvData)[$i], size: $e.rgsabound[$r].cElements, rank: $e.cDims, base: $e.rgsabound[$r].lLbound )
			)
		)
	)
}
tagPROPVARIANT|tagVARIANT|PROPVARIANT|VARIANT{
	preview(
		#switch ($e.vt)
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;;		Base Types		;;
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		#case 0 ( #("Empty") )	; VT_EMPTY
		#case 1 ( #("NULL") )	; VT_NULL
		#case 2 ( #("I2 = ", $e.iVal) ) ; VT_I2
		#case 3 ( #("I4 = ", $e.lVal) ) ; VT_I4
		#case 4 ( #("R4 = ", $e.fltVal) )		; VT_R4
		#case 5 ( #("R8 = ", $e.dblVal) )		; VT_R8
		#case 6 ( #("CY = ", $e.cyVal) )		; VT_CY
		#case 7 ( #("DATE =  ", $e.date) )		; VT_DATE
		#case 8 ( #("BSTR = ", $e.bstrVal) )	; VT_BSTR
		#case 9 ( #("DISPATCH =  ", $e.pdispVal) )		; VT_DISPATCH
		#case 10 ( #("ERROR =  ", $e.scode) )	; VT_ERROR
		#case 0xB ( #("BOOL =  ", $e.boolVal) ) ; VT_BOOL
		#case 0xC ( #("VARIANT ") )		; VT_VARIANT
		#case 0xD ( #("UNKNOWN =  ", $e.punkVal) )		; VT_UNKOWN
		#case 0xE ( #("DECIMAL = ", $e.decVal) )		; VT_DECIMAL
		#case 0x10 ( #("I1 =  ", $e.cVal) )		; VT_I1
		#case 0x11 ( #("UI1 =  ", $e.bVal) )	; VT_UI1
		#case 0x12 ( #("UI2 =  ", $e.uiVal) )	; VT_UI2
		#case 0x13 ( #("UI4 =  ", $e.ulVal) )	; VT_UI4
		#case 0x14 ( #("I8 =  ", *(__int64*)&$e.dblVal) )	; VT_I8
		#case 0x15 ( #("UI8 =  ", *(unsigned __int64*)&$e.dblVal) )	; VT_UI8
		#case 0x16 ( #("INT =  ", $e.intVal) )	; VT_INT
		#case 0x17 ( #("UINT = ", $e.uintVal) ) ; VT_UINT
		#case 0x18 ( #("VOID ") )		; VT_VOID
		#case 0x19 ( #("HRESULT ") )	; VT_HRESULT
		#case 0x1A ( #("PTR ") )		; VT_PTR
		#case 0x1B ( #("SAFEARRAY ") )	; VT_SAFEARRAY
		#case 0x1C ( #("CARRAY ") )		; VT_CARRAY
		#case 0x1D ( #("USERDEFINED ") )		; VT_USERDEFINED
		#case 0x1E ( #("LPSTR =  ", $e.pszVal) )		; VT_LPSTR
		#case 0x1F ( #("LPWSTR =  ", $e.pwszVal) )		; VT_LPWSTR
		#case 0x24 ( #("RECORD	") )	; VT_RECORD
		#case 0x26 ( #("UINT_PTR ") )	; VT_UINT_PTR
		#case 0x40 ( #("FILETIME =	", $e.filetime) )	; VT_FILETIME
		#case 0x42 ( #("STREAM =  ", $e.pStream) )		; VT_STREAM
		#case 0x43 ( #("STORAGE = ", $e.pStorage) )		; VT_STORAGE
		#case 0x44 ( #("STREAMED_OBJECT =  ", $e.pStream) )		; VT_STREAMED_OBJECT
		#case 0x45 ( #("STORED_OBJECT =  ", $e.pStorage) )		; VT_STORED_OBJECT
		#case 0x46 ( #("BLOB_OBJECT = ", $e.blob ) )	; VT_BLOB_OBJECT
		#case 0x47 ( #("CF =  ", $e.pclipdata) )		; VT_CF
		#case 0x48 ( #("CLSID = ", $e.puuid) )	; VT_CLSID
		#case 0x49 ( #("VERSIONED_STREAM = ", $e.pVersionedStream) )	; VT_VERSIONED_STREAM
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;;	 Vector types		;;
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		#case 0x1002 ( #("vector of I2 = ", $e.cai) )	; VT_I2|VT_VECTOR
		#case 0x1003 ( #("vector of I4 = ", $e.cal) )	; VT_I4|VT_VECTOR
		#case 0x1004 ( #("vector of R4 = ", $e.caflt) ) ; VT_R4|VT_VECTOR
		#case 0x1005 ( #("vector of R8 = ", $e.cadbl) ) ; VT_R8|VT_VECTOR
		#case 0x1010 ( #("vector of I1 =  ", $e.cac) )	; VT_I1|VT_VECTOR
		#case 0x1011 ( #("vector of UI1 =  ", $e.caub) )		; VT_UI1|VT_VECTOR
		#case 0x1012 ( #("vector of UI2 =  ", $e.caui) )		; VT_UI2|VT_VECTOR
		#case 0x1013 ( #("vector of UI4 =  ", $e.caul) )		; VT_UI4|VT_VECTOR
		#case 0x1014 ( #("vector of I8 =  ", $e.cah) )	; VT_I8|VT_VECTOR
		#case 0x1015 ( #("vector of UI8 =  ", $e.cauh) )		; VT_UI8|VT_VECTOR
		#case 0x101E ( #("vector of LPSTR =  ", $e.calpstr) )	; VT_LPSTR|VT_VECTOR
		#case 0x101F ( #("vector of LPWSTR =  ", $e.calpwstr) ) ; VT_LPWSTR|VT_VECTOR
		#case 0x100C ( #("vector of VARIANT ", $e.capropvar) )	; VT_VARIANT|VT_VECTOR
		#case 0x100B ( #("vector of BOOL =	", $e.cabool) )		; VT_BOOL|VT_VECTOR
		#case 0x100A ( #("vector of ERROR =  ", $e.cascode) )	; VT_ERROR|VT_VECTOR
		#case 0x1006 ( #("vector of CY = ", $e.cacy) )	; VT_CY|VT_VECTOR
		#case 0x1007 ( #("vector of DATE =	", $e.cadate) )		; VT_DATE|VT_VECTOR
		#case 0x1040 ( #("vector of FILETIME =	", $e.cafiletime) )		; VT_FILETIME|VT_VECTOR
		#case 0x1048 ( #("vector of CLSID = ", $e.cauuid) )		; VT_CLSID|VT_VECTOR
		#case 0x1047 ( #("vector of CF =  ", $e.caclipdata) )	; VT_CF|VT_VECTOR
		#case 0x1008 ( #("vector of BSTR = ", $e.cabstr) )		; VT_BSTR|VT_VECTOR
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;;	 Byref Types		;;
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		#case 0x4016 ( #("byref of INT =  ", $e.pintVal) )		; VT_INT|VT_BYREF
		#case 0x4017 ( #("byref of UINT = ", $e.puintVal) )		; VT_UINT|VT_BYREF
		#case 0x4002 ( #("byref of I2 = ", $e.piVal) )	; VT_I2|VT_BYREF
		#case 0x4003 ( #("byref of I4 = ", $e.plVal) )	; VT_I4|VT_BYREF
		#case 0x4004 ( #("byref of R4 = ", $e.pfltVal) )		; VT_R4|VT_BYREF
		#case 0x4005 ( #("byref of R8 = ", $e.pdblVal) )		; VT_R8|VT_BYREF
		#case 0x4010 ( #("byref of I1 =  ", $e.pcVal) ) ; VT_I1|VT_BYREF
		#case 0x4011 ( #("byref of UI1 =  ", $e.pbVal) )		; VT_UI1|VT_BYREF
		#case 0x4012 ( #("byref of UI2 =  ", $e.puiVal) )		; VT_UI2|VT_BYREF
		#case 0x4013 ( #("byref of UI4 =  ", $e.pulVal) )		; VT_UI4|VT_BYREF
		#case 0x4014 ( #("byref of I8 =  ", (__int64*)$e.pdblVal) )		; VT_I8|VT_BYREF
		#case 0x4015 ( #("byref of UI8 =  ", (unsigned __int64*)$e.pudblVal) )		; VT_UI8|VT_BYREF
		#case 0x400C ( #("byref of VARIANT ", $e.pvarVal) )		; VT_VARIANT|VT_BYREF
		#case 0x400B ( #("byref of BOOL =  ", $e.pboolVal) )	; VT_BOOL|VT_BYREF
		#case 0x400A ( #("byref of ERROR =	", $e.pscode) )		; VT_ERROR|VT_BYREF
		#case 0x4006 ( #("byref of CY = ", $e.pcyVal) ) ; VT_CY|VT_BYREF
		#case 0x4007 ( #("byref of DATE =  ", $e.pdate) )		; VT_DATE|VT_BYREF
		#case 0x4008 ( #("byref of BSTR = ", $e.pbstrVal) )		; VT_BSTR|VT_BYREF
		#case 0x400E ( #("byref of DECIMAL = ", $e.pdecVal) )	; VT_DECIMAL|VT_BYREF
		#case 0x400D ( #("byref of UNKNOWN =  ", $e.ppunkVal) ) ; VT_UNKOWN|VT_BYREF
		#case 0x4009 ( #("byref of DISPATCH =  ", $e.ppdispVal) )		; VT_DISPATCH|VT_BYREF
		#case 0x6000 ( #("byref of ARRAY =	", $e.pparray) )	; VT_ARRAY|VT_BYREF
		#default
		(
			#if ($e.vt & 0x2000) ( $e.parray)
			#else ( #("Unknown vt type = ", $e.vt))
		)
	)
	children(
		#(
			vt: $e.vt,
			#switch ($e.vt)
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			;;		Base Types		;;
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			#case 0x2 ( #(I2  : $e.iVal) )	; VT_I2
			#case 0x3 ( #(I4  : $e.lVal) )	; VT_I4
			#case 0x4 ( #(R4  : $e.fltVal) )		; VT_R4
			#case 0x5 ( #(R8  : $e.dblVal) )		; VT_R8
			#case 0x6 ( #(CY  : $e.cyVal) ) ; VT_CY
			#case 0x7 ( #(DATE	 : $e.date) )		; VT_DATE
			#case 0x8 ( #(BSTR	: $e.bstrVal) )		; VT_BSTR
			#case 0x9 ( #(DISPATCH	 : $e.pdispVal) )		; VT_DISPATCH
			#case 0xA ( #(ERROR   : $e.scode) )		; VT_ERROR
			#case 0xB ( #(BOOL	 : $e.boolVal) )	; VT_BOOL
			#case 0xD ( #(UNKNOWN	: $e.punkVal) ) ; VT_UNKOWN
			#case 0xE ( #(DECIMAL  : $e.decVal) )	; VT_DECIMAL
			#case 0x10 ( #(I1	: $e.cVal) )		; VT_I1
			#case 0x11 ( #(UI1	 : $e.bVal) )		; VT_UI1
			#case 0x12 ( #(UI2	 : $e.uiVal) )		; VT_UI2
			#case 0x13 ( #(UI4	 : $e.ulVal) )		; VT_UI4
			#case 0x14 ( #(I8	: *(__int64*)&$e.dblVal) )		; VT_I8
			#case 0x15 ( #(UI8	 : *(unsigned __int64*)&$e.dblVal) )		; VT_UI8
			#case 0x16 ( #(INT	 : $e.intVal) )		; VT_INT
			#case 0x17 ( #(UINT  : $e.uintVal) )	; VT_UINT
			#case 0x1E ( #(LPSTR   : $e.pszVal) )	; VT_LPSTR
			#case 0x1F ( #(LPWSTR	: $e.pwszVal) ) ; VT_LPWSTR
			#case 0x40 ( #(FILETIME   : $e.filetime) )		; VT_FILETIME
			#case 0x42 ( #(STREAM	: $e.pStream) ) ; VT_STREAM
			#case 0x43 ( #(STORAGE	: $e.pStorage) )		; VT_STORAGE
			#case 0x44 ( #(STREAMED_OBJECT	 : $e.pStream) )		; VT_STREAMED_OBJECT
			#case 0x45 ( #(STORED_OBJECT   : $e.pStorage) ) ; VT_STORED_OBJECT
			#case 0x46 ( #(BLOB_OBJECT	: $e.blob ) )		; VT_BLOB_OBJECT
			#case 0x47 ( #(CF	: $e.pclipdata) )	; VT_CF
			#case 0x48 ( #(CLSID  : $e.puuid) )		; VT_CLSID
			#case 0x49 ( #(VERSIONED_STREAM  : $e.pVersionedStream) )		; VT_VERSIONED_STREAM
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			;;	 Vector types		;;
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			#case 0x1002 ( #(vector of I2  : $e.cai) )		; VT_I2|VT_VECTOR
			#case 0x1003 ( #(vector of I4  : $e.cal) )		; VT_I4|VT_VECTOR
			#case 0x1004 ( #(vector of R4  : $e.caflt) )	; VT_R4|VT_VECTOR
			#case 0x1005 ( #(vector of R8  : $e.cadbl) )	; VT_R8|VT_VECTOR
			#case 0x1010 ( #(vector of I1	: $e.cac) )		; VT_I1|VT_VECTOR
			#case 0x1011 ( #(vector of UI1	 : $e.caub) )	; VT_UI1|VT_VECTOR
			#case 0x1012 ( #(vector of UI2	 : $e.caui) )	; VT_UI2|VT_VECTOR
			#case 0x1013 ( #(vector of UI4	 : $e.caul) )	; VT_UI4|VT_VECTOR
			#case 0x1014 ( #(vector of I8	: $e.cah) )		; VT_I8|VT_VECTOR
			#case 0x1015 ( #(vector of UI8	 : $e.cauh) )	; VT_UI8|VT_VECTOR
			#case 0x101E ( #(vector of LPSTR   : $e.calpstr) )		; VT_LPSTR|VT_VECTOR
			#case 0x101F ( #(vector of LPWSTR	: $e.calpwstr) )	; VT_LPWSTR|VT_VECTOR
			#case 0x100C ( #(vector of VARIANT : $e.capropvar) )	; VT_VARIANT|VT_VECTOR
			#case 0x100B ( #(vector of BOOL   : $e.cabool) )		; VT_BOOL|VT_VECTOR
			#case 0x100A ( #(vector of ERROR   : $e.cascode) )		; VT_ERROR|VT_VECTOR
			#case 0x1006 ( #(vector of CY  : $e.cacy) )		; VT_CY|VT_VECTOR
			#case 0x1007 ( #(vector of DATE   : $e.cadate) )		; VT_DATE|VT_VECTOR
			#case 0x1040 ( #(vector of FILETIME   : $e.cafiletime) )		; VT_FILETIME|VT_VECTOR
			#case 0x1048 ( #(vector of CLSID  : $e.cauuid) )		; VT_CLSID|VT_VECTOR
			#case 0x1047 ( #(vector of CF	: $e.caclipdata) )		; VT_CF|VT_VECTOR
			#case 0x1008 ( #(vector of BSTR  : $e.cabstr) ) ; VT_BSTR|VT_VECTOR
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			;;	 Byref Types		;;
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			#case 0x4016 ( #(byref of INT	: $e.pintVal) ) ; VT_INT|VT_BYREF
			#case 0x4017 ( #(byref of UINT	: $e.puintVal) )		; VT_UINT|VT_BYREF
			#case 0x4002 ( #(byref of I2  : $e.piVal) )		; VT_I2|VT_BYREF
			#case 0x4003 ( #(byref of I4  : $e.plVal) )		; VT_I4|VT_BYREF
			#case 0x4004 ( #(byref of R4  : $e.pfltVal) )	; VT_R4|VT_BYREF
			#case 0x4005 ( #(byref of R8  : $e.pdblVal) )	; VT_R8|VT_BYREF
			#case 0x4010 ( #(byref of I1   : $e.pcVal) )	; VT_I1|VT_BYREF
			#case 0x4011 ( #(byref of UI1	: $e.pbVal) )	; VT_UI1|VT_BYREF
			#case 0x4012 ( #(byref of UI2	: $e.puiVal) )	; VT_UI2|VT_BYREF
			#case 0x4013 ( #(byref of UI4	: $e.pulVal) )	; VT_UI4|VT_BYREF
			#case 0x4014 ( #(byref of I8	: (__int64*)$e.pdblVal) )	; VT_I8|VT_BYREF
			#case 0x4015 ( #(byref of UI8	: (unsigned __int64*)$e.pdblVal) ) ; VT_UI8|VT_BYREF
			#case 0x400C ( #(byref of VARIANT : $e.pvarVal) )		; VT_VARIANT|VT_BYREF
			#case 0x400B ( #(byref of BOOL	 : $e.pboolVal) )		; VT_BOOL|VT_BYREF
			#case 0x400A ( #(byref of ERROR   : $e.pscode) )		; VT_ERROR|VT_BYREF
			#case 0x4006 ( #(byref of CY  : $e.pcyVal) )	; VT_CY|VT_BYREF
			#case 0x4007 ( #(byref of DATE	 : $e.pdate) )	; VT_DATE|VT_BYREF
			#case 0x4008 ( #(byref of BSTR	: $e.pbstrVal) )		; VT_BSTR|VT_BYREF
			#case 0x400E ( #(byref of DECIMAL  : $e.pdecVal) )		; VT_DECIMAL|VT_BYREF
			#case 0x400D ( #(byref of UNKNOWN	: $e.ppunkVal) )	; VT_UNKOWN|VT_BYREF
			#case 0x4009 ( #(byref of DISPATCH	 : $e.ppdispVal) )	; VT_DISPATCH|VT_BYREF
			#case 0x6000 ( #(byref of ARRAY   : $e.pparray) )		; VT_ARRAY|VT_BYREF

			; the following are either empty or invalid vt values for a variant
			; #case 0 ( #(Empty :) )		; VT_EMPTY
			; #case 0x1 ( #(NULL :) )		; VT_NULL
			; #case 0xC ( #(VARIANT :) )	; VT_VARIANT
			; #case 0x18 ( #(VOID :) )		; VT_VOID
			; #case 0x19 ( #(HRESULT :) )	; VT_HRESULT
			; #case 0x1A ( #(PTR :) )		; VT_PTR
			; #case 0x1B ( #(SAFEARRAY :) ) ; VT_SAFEARRAY
			; #case 0x1C ( #(CARRAY :) )	; VT_CARRAY
			; #case 0x1D ( #(USERDEFINED :) )		; VT_USERDEFINED
			; #case 0x24 ( #(RECORD  :) )	; VT_RECORD
			; #case 0x26 ( #(UINT_PTR :) )	; VT_UINT_PTR
			#default
			(
				#if ($e.vt & 0x2000 )
					( #(safearray: $e.parray))
				#else
				(
					#(
						[raw members]: [$e,!]	; unformatted data members
					 )
				 )
			)
			#except
			(
				#(
					[raw members]: [$e,!]	; unformatted data members
				 )
			)
		)
	)
}
; This section lets you define your own errors for the HRESULT display.
; You need to list the error code in unsigned decimal, followed by the message.
; Changes will take effect the next time you redisplay the variable.

[hresult]
;1234=my custom error code

